Total number of possible Binary Search Trees with n different keys
Catalan number Cn = (2n)!/(n+1)!*n! : 2nCn / (n + 1)

Triangle area
area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))

arc angle
math.degrees(math.atan2(p[1] - loc[1], p[0] - loc[0])))

find median from sorted list (odd and even)
medianList.append((sortedList[(k - 1) // 2] + sortedList[k // 2]) / 2)

When we subtract a number by 1 and do bitwise & with itself (n & (n-1)), we unset the rightmost set bit

For a given array, if we create all possible subarray. Number at i-th index will have (i + 1) * (N - i) frequency.

i += i & (-i); Add 1 to last set bit of i
i -= i & (-i); Subtract 1 from last set bit of i

Let Points be A and B. So line can be represent by : c1 = a1*A.x + b1*A.y
where a1 = B.y - A.y; b1 = A.x - B.x
Now find determinant b/w lines
determinant = float(a1*b2 - a2*b1)
To find intersecting points :
if determinant == 0: print ("Given lines are parallel")
else: x = (b2*c1 - b1*c2) / determinant; y = (a1*c2 - a2*c1) / determinant

Recall the quadratic formula:
x = [-b +- sqrt(b^2 - 4ac)] / 2a

for interval in intervals:
    events.append(Event('open', interval[0], interval[2]))
    events.append(Event('close', interval[1], interval[2]))
events.sort(key=lambda x: x.time)

quicksort
partition(arr, left, right, pivotLeft, pivotRight):
i = (left - 1) # index of smaller element
pivot = arr[right] # pivot
for j in range(left, right):
    if arr[j] <= pivot:
    i = i + 1
    arr[i], arr[j] = arr[j], arr[i]
arr[i + 1], arr[right] = arr[right], arr[i + 1]
pivotPosition = i + 1
pivot = arr[i + 1]

josephus(n, k) = (josephus(n - 1, k) + k-1) % n + 1
josephus(1, k) = 1

level order
class Node:
    def __init__(self, data):
        self.data = data
        self.hd = sys.maxsize
        self.left = None
        self.right = None

# dict sorted on keys
for key in sorted(map):
    print(map[key], end=" ")

# BFS
while queue:
    cost, node = queue.pop(0)
    nodeIndex = node[0]
    visitedNodes = node[1]
    if visitedNodes == targetVisit:
        return cost

c = a ^ b

# multiply without operator
res = 0
while b > 0:
if b & 1: res = res + a
    a <<= 1
    b >>= 1
return res

INT_BIT = sys.getsizeof(int())

---------------------------------------------------------------------------------
AP Formula : Sn = n/2(2a + (n-1)d)

class TrieNode:
    def __init__(self):
        self.children = dict()
        self.word = ''

def build_trie(words):
    trie = TrieNode()
    for word in words:
        temp = trie
        for ch in word:
            if ch not in temp.children:
                temp.children[ch] = TrieNode()
            temp = temp.children[ch]
        temp.word = word
    return trie

Merge sort
# Uses Auxiliary space
# Better for large data structure

Quick Sort
# Worst case is O(n^2) for already sorted
# Locality of reference

# Parent union
# We cannot use union-find to detect cycles in a directed graph.
def sample():
    def union(i, j, ids):
        ids[find(i, ids)] = find(j, ids)

    def find(i, ids):
        while i != ids[i]:
            ids[i] = ids[ids[i]] # Set grandparent to parent
            i = ids[i]
        return i

    # To be called after all unions to find grandfather as well.
    for i in range(len(ids)):
        find(i, ids)

    # complexity : O(e log v) where e is the number of edges in the graph and v is the number of vertices.


Eulerian Path is a path in graph that visits every edge exactly once. Eulerian
Circuit is an Eulerian Path which starts and ends on the same vertex.
For that these two conditions must be met:
1) All vertices with nonzero degree belong to a single strongly connected component.
2) In degree and out degree of every vertex is same

for node in route:
    graph[node] = graph.get(node, []) + [i]

# Sort in decreasing order based on area.
allBoxList.sort(key=lambda x: x.getArea(), reverse=True)

# Use the sorted func with key as second element i.e. score
result = sorted(inpArr, key=lambda x: x[1])

import functools
def comparator(a, b):
    return a-b
print(sorted(A1, key=functools.cmp_to_key(comparator)))

For a matrix, diff of indices are same for diagonal (left to right)
sum of indices are same for diagonal (right to left)

A set of n can have 2^n subsets. (power subset)

To get sorted key in dict, loop from min(keys) to max(keys).
We can get a sorted list by looping through it. Remember to increment while ele not found.

# It is known for a string of length n, there are a total of n*(n+1)/2 number of substrings.
# n items make n*(n-1)/2 pairs

import heapq
heapq.heapify(pool)
heapq.heappush(pool, q) # Min heap
heapq.heappush(pool, -q) # Max heap
sumq += heapq.heappop(pool)

def charToIndex(ch):
    return ord(ch) - ord('a')

def indexToChar(i):
    return chr(i + ord('a'))

import sys
sys.maxsize

while left < right:
    mid = left + (right - left) // 2

# To make all possible pairs without index
for item_1,item_2 in zip(top, top[1:]):

# To make all possible pairs with index
for i,[x,y] in enumerate(sensors):
    for I,[X,Y] in enumerate(sensors[i+1:],i+1):

# binary representation
print (bin(covered_skill))

# math library example
import math
dist = math.sqrt(math.pow(x2 - x1, 2) + math.pow(y2 - y1, 2))

class KStacks:
    def __init__(self, k, n):
        self.k = k  # Number of stacks.
        self.n = n  # Total size of array holding all the 'k' stacks.

if __name__ == "__main__":

# Return a list as a string with no delimiter
return "".join(digits)

# round upto D digits
return round(mid, D)

# Revise : ACID, CAP, SOLID and SQL VS NOSQL
# SQL : (ACID, structured data, constraints handled, slow query, DB design takes time, not changing data)
# NOSQL : (no ACID, non structured data, constraints handled in code, fast query,
#         DB design not required, lacking of reporting tool, easier scalabilty, used to store large data)

# Fetch row using SQLAlchemy
query = select(document).where(document.c.document_id == document_id)
res = db_session.execute(query)
return res.one_or_none()

# LRU implementation https://www.geeksforgeeks.org/lru-cache-in-python-using-ordereddict/
# OrderedDict is implemented using double linked list.
from collections import OrderedDict
cache = OrderedDict()
cache[key] = value
cache.move_to_end(key)     # Move recently used item to end.
cache.popitem(last=False)  # Remove least recently used item from front.

from datetime import datetime, timedelta
past = datetime.now() - timedelta(days=1)
present = datetime.now()
past < present   # True
datetime(3000, 1, 1) < present # False
present - datetime(2000, 4, 4) = datetime.timedelta(days=8515, seconds=56256, microseconds=871972)

return "".join(str(digits) for digits in reversed(answer))

# Find index of element from list
index = animals.index('dog')
print(index)

#error
ValueError: 'dog' is not in list

# Remove ele from list
prime_numbers.remove(9)

a=[1,2,3,4,5,6,7]
a[:2] : [1, 2] ## first two elements
a[2:] : [3, 4, 5, 6, 7] ## Print all elements from index 2
a[2] : [1, 2] ## Second element

# For minus, assume index from right as -1, -2, -3, -4
a[-2] : 6 ## Second last element
a[-2:] : [6, 7] ## last two elements
a[:-2] : [1, 2, 3, 4, 5] ## Print all elements except last two

a[:-2] + a[-2:] : [1, 2, 3, 4, 5, 6, 7] ## Partition the array at last 2

a[::-1] : [7, 6, 5, 4, 3, 2, 1] ## Reverse the given array

a[::] : [1,2,3,4,5,6,7] ## Copy of given array
a[0:2] : [1, 2] ## end index is not included in the range.
---------------------------------------------------------------
