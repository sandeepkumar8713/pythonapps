AP Formula : Sn = n/2(2a + (n-1)d)

Total number of possible Binary Search Trees with n different keys
Catalan number Cn = (2n)!/(n+1)!*n! : 2nCn / (n + 1)

Triangle area
area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))

arc angle
math.degrees(math.atan2(p[1] - loc[1], p[0] - loc[0])))

find median from sorted list (odd and even)
medianList.append((sortedList[(k - 1) // 2] + sortedList[k // 2]) / 2)

For a matrix, diff of indices are same for diagonal (left to right)
sum of indices are same for diagonal (right to left)

A set of n can have 2^n subsets. (power subset)

To get sorted key in dict, loop from min(keys) to max(keys).

When we subtract a number by 1 and do bitwise & with itself (n & (n-1)), we unset the rightmost set bit

For a given array, if we create all possible subarray. Number at i-th index will have (i + 1) * (N - i) frequency.

i += i & (-i); Add 1 to last set bit of i
i -= i & (-i); Subtract 1 from last set bit of i

It is known for a string of length n, there are a total of n*(n+1)/2 number of substrings.

Let Points be A and B. So line can be represent by : c1 = a1*A.x + b1*A.y
where a1 = B.y - A.y; b1 = A.x - B.x
Now find determinant b/w lines
determinant = float(a1*b2 - a2*b1)
To find intersecting points :
if determinant == 0: print ("Given lines are parallel")
else: x = (b2*c1 - b1*c2) / determinant; y = (a1*c2 - a2*c1) / determinant

Recall the quadratic formula:
x = [-b +- sqrt(b^2 - 4ac)] / 2a

Use the sorted func with key as second element i.e. score
result = sorted(inpArr, key=lambda x: x[1])

for interval in intervals:
    events.append(Event('open', interval[0], interval[2]))
    events.append(Event('close', interval[1], interval[2]))
events.sort(key=lambda x: x.time)

def comparator(a, b):
    return a-b
print(sorted(A1, key=functools.cmp_to_key(comparator)))

quicksort
partition(arr, left, right, pivotLeft, pivotRight):
i = (left - 1) # index of smaller element
pivot = arr[right] # pivot
for j in range(left, right):
    if arr[j] <= pivot:
    i = i + 1
    arr[i], arr[j] = arr[j], arr[i]
arr[i + 1], arr[right] = arr[right], arr[i + 1]
pivotPosition = i + 1
pivot = arr[i + 1]

josephus(n, k) = (josephus(n - 1, k) + k-1) % n + 1
josephus(1, k) = 1

import heapq
heapq.heapify(pool)
heapq.heappush(pool, q) # Min heap
heapq.heappush(pool, -q) # Max heap
sumq += heapq.heappop(pool)

def charToIndex(ch):
    return ord(ch) - ord('a')

def indexToChar(i):
    return chr(i + ord('a'))

sys.maxsize

while left < right:
    mid = left + (right - left) / 2

level order
class Node:
    def __init__(self, data):
        self.data = data
        self.hd = sys.maxsize
        self.left = None
        self.right = None

# dict sorted on keys
for key in sorted(map):
    print(map[key], end=" ")

# BFS
while queue:
    cost, node = queue.pop(0)
    nodeIndex = node[0]
    visitedNodes = node[1]
    if visitedNodes == targetVisit:
        return cost

c = a ^ b

# multiply without operator
res = 0
while b > 0:
if b & 1: res = res + a
    a <<= 1
    b >>= 1
return res

INT_BIT = sys.getsizeof(int())

class TrieNode():
    def __init__(self):
        self.children = dict()
        self.word = ''

def build_trie(words):
    trie = TrieNode()
    for word in words:
        temp = trie
        for ch in word:
            if ch not in temp.children:
                temp.children[ch] = TrieNode()
            temp = temp.children[ch]
        temp.word = word
    return trie

Merge sort
# Auxiliary space
# better for large data structure

Quick Sort
# Worst case
# Locality of reference
